(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{193:function(e,v,r){"use strict";r.r(v);var _=r(0),t=Object(_.a)({},function(){var e=this,v=e.$createElement,r=e._self._c||v;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("p",[e._v("Martini框架")]),e._v(" "),r("p",[e._v("martini框架是go语言轻量级的后端框架，使用简单易上手，极佳的路由匹配与转发，同时扩展性极强，模块化的中间件设计，这些都是它的特点，特别是利用依赖注入的思想，下面我们结合源码来讲讲吧。")]),e._v(" "),r("p",[e._v("martini.go这个源码文件主要包含Martini这个结构体，里面包含Injector, logger以及中间件Handler。")]),e._v(" "),r("p",[e._v("type Martini struct {")]),e._v(" "),r("p",[e._v("inject.Injector // 依赖注入的调用者")]),e._v(" "),r("p",[e._v("handlers []Handler // 中间件函数")]),e._v(" "),r("p",[e._v("action Handler // 路由匹配，路由转发,在所有中间件函数处理后再执行")]),e._v(" "),r("p",[e._v("logger *log.Logger // 日志")]),e._v(" "),r("p",[e._v("}")]),e._v(" "),r("p",[e._v("inject.go主要是实现依赖注入，用于存储中间件函数以及用户自定义函数回调时的参数。依赖注入不同于传统编程，传统编程是调用者自己来决定使用那些被调用者实现的，而依赖注入则是由注入器(injector)来决定，注入器创建被调用者，注入调用者。例如：在inject.go中，被调用者为func，注入属性就是对func注入实参。")]),e._v(" "),r("p",[e._v("router.go主要是实现路由匹配，路由转发，分组路由等功能。")]),e._v(" "),r("p",[e._v("通过阅读源码之后，发现martini框架核心的源码，其实就是martini.go, inject.go以及router.go，下面就来仔细分析一下每个类的功能与作用。")]),e._v(" "),r("p",[e._v("inject.go源码")]),e._v(" "),r("p",[e._v("依赖注入核心是inject.go代码，辅助实现martini机具扩展性的中间件。")]),e._v(" "),r("p",[e._v("先来讲讲inject.go:")]),e._v(" "),r("p",[e._v("type Injector struct {")]),e._v(" "),r("p",[e._v("Application // 结构体各个字段赋值")]),e._v(" "),r("p",[e._v("Invoker // 通过反射实现函数调用的接口")]),e._v(" "),r("p",[e._v("TypeMapper //Maps以val的反射Type为key,反射Value为值")]),e._v(" "),r("p",[e._v("SetParent(Injector) // 设置父Injector")]),e._v(" "),r("p",[e._v("}")]),e._v(" "),r("p",[e._v("type injector struct {")]),e._v(" "),r("p",[e._v("values map[reflect.Type]reflect.Value // 存放注入参数的类型和值")]),e._v(" "),r("p",[e._v("parent Injector // 父节点")]),e._v(" "),r("p",[e._v("}")]),e._v(" "),r("p",[e._v("type TypeMapper interface {")]),e._v(" "),r("p",[e._v("Map(interface{}) TypeMapper // 具体类型的映射,根据值的具体类型直接建立映射")]),e._v(" "),r("p",[e._v("MapTo(interface{}, interface{}) TypeMapper //转化类型映射")]),e._v(" "),r("p",[e._v("….")]),e._v(" "),r("p",[e._v("}")]),e._v(" "),r("p",[e._v("这是几个关键的结构体，具体实现依赖注入就是，将Func以type Handler interface{} 的形式注入，其中参数保存在values的map中，调用方法时，遍历这个方法有的参数的Type，去values中获取对应的值，再使用Call方法实现调用。")]),e._v(" "),r("p",[e._v("直观点说，Injector通过TypeMapper注入方法，与参数值到values中，通过Invoker.invoke去调用注入的方法，调用方法时，获取方法入参的Type，在通过values获取值，实现调用。")]),e._v(" "),r("p",[e._v("martini.go源码")]),e._v(" "),r("p",[e._v("type Martini struct {")]),e._v(" "),r("p",[e._v("inject.Injector // 注入器，匿名类")]),e._v(" "),r("p",[e._v("handlers []Handler // 中间件函数")]),e._v(" "),r("p",[e._v("action Handler // 请求中间件函数处理后，进行路由分发")]),e._v(" "),r("p",[e._v("logger *log.Logger //日志")]),e._v(" "),r("p",[e._v("}")]),e._v(" "),r("p",[e._v("type context struct { //每个请求上下文")]),e._v(" "),r("p",[e._v("inject.Injector // 注入器")]),e._v(" "),r("p",[e._v("handlers []Handler // 中间件函数")]),e._v(" "),r("p",[e._v("action Handler // 最后的路由分发处理")]),e._v(" "),r("p",[e._v("rw ResponseWriter // 每个返回值")]),e._v(" "),r("p",[e._v("index int // 索引")]),e._v(" "),r("p",[e._v("}")]),e._v(" "),r("p",[e._v("我们在运行martini框架时，生成一个单例，包含所有注入器，中间件函数，路由；每个请求过来时，会调用createContext创建一个上下文，此时把各种中间件，注入器赋值进去。这样就可以实现每个请求过同样的中间件。中间件是一个type Handler interface{} 的函数，也就是中间件的Type一定要是函数，且返回的是一个参数，可以是基础类型或者结构体。")]),e._v(" "),r("p",[e._v("router.go源码")]),e._v(" "),r("p",[e._v("主要实现路由的存储与转发。")]),e._v(" "),r("p",[e._v("type router struct {")]),e._v(" "),r("p",[e._v("routes []*route // 存入各种方式的路由(Post,Get等)")]),e._v(" "),r("p",[e._v("notFounds []Handler")]),e._v(" "),r("p",[e._v("groups []group // 实现路由分组")]),e._v(" "),r("p",[e._v("routesLock sync.RWMutex")]),e._v(" "),r("p",[e._v("}")]),e._v(" "),r("p",[e._v("type route struct {")]),e._v(" "),r("p",[e._v("method string // 请求方式(Get or Post)")]),e._v(" "),r("p",[e._v("regex *regexp.Regexp // 正则匹配")]),e._v(" "),r("p",[e._v("handlers []Handler // 路由方法")]),e._v(" "),r("p",[e._v("pattern string // 路由地址")]),e._v(" "),r("p",[e._v("name string")]),e._v(" "),r("p",[e._v("}")]),e._v(" "),r("p",[e._v("router结构体主要是存储所有post，get等请求的路由方式；route结构体就是存储的具体路由方法，路由地址。")]),e._v(" "),r("p",[e._v("martini总结")]),e._v(" "),r("p",[e._v("整个Martini框架运行的模式，我们生成一个Martini的单例。")]),e._v(" "),r("p",[e._v("1.通过martini.Use()来添加Handler中间件，Use添加中间件之后，每个请求都会过这个中间件。")]),e._v(" "),r("p",[e._v("2.通过martini.Map()以及martini.MapTo()来注入每个Handler的参数与值。")]),e._v(" "),r("p",[e._v("3.router.go路由器中，Post和Get等方法用来添加路由地址和路由方法。")]),e._v(" "),r("p",[e._v("当请求来到，每个请求会createContext的上下文，context.run()用户运行每个中间件Handler，最后去调用martini.Action开始路由分发，匹配路由地址，执行Post或者Get方法，之后ResponseWriter写回返回值，本次请求结束。")]),e._v(" "),r("p",[e._v("Echo框架")]),e._v(" "),r("p",[e._v("echo框架是go语言轻量级后端框架，它主要特点就是在所有web框架中，路由性能最好，各种灵活的中间件，两个框架使用上都是异曲同工，下面我们深入理解echo框架的原理吧。")]),e._v(" "),r("p",[e._v("在echo框架源码中，主要文件echo.go，router.go文件。直接看看echo.go源码吧。")]),e._v(" "),r("p",[e._v("Echo struct {")]),e._v(" "),r("p",[e._v("premiddleware []MiddlewareFunc // 中间件函数，执行路由分发前")]),e._v(" "),r("p",[e._v("middleware []MiddlewareFunc // 中间件函数，执行路由分发后")]),e._v(" "),r("p",[e._v("router *Router // 路由分发router")]),e._v(" "),r("p",[e._v("Server *http.Server // 服务端参数")]),e._v(" "),r("p",[e._v("TLSServer *http.Server // 安全加密协议服务端")]),e._v(" "),r("p",[e._v("Listener net.Listener //服务端监听器")]),e._v(" "),r("p",[e._v("TLSListener net.Listener // 安全加密服务端监听器")]),e._v(" "),r("p",[e._v("Binder Binder // 数据处理器")]),e._v(" "),r("p",[e._v("Validator Validator // 初始化校检")]),e._v(" "),r("p",[e._v("Renderer Renderer // 请求模板")]),e._v(" "),r("p",[e._v("Logger Logger // 自定义日志")]),e._v(" "),r("p",[e._v("…..")]),e._v(" "),r("p",[e._v("}")]),e._v(" "),r("p",[e._v("echo框架对中间件函数分为路由前和路由后，路由前指当请求到达服务端后，还没有通过router匹配到指定的路由函数；路由后就是指此时已经执行由router匹配后的路由函数。两者有什么使用场景呢？路由前，我们可以拿来做限流，鉴权，降级等支持服务端稳定性的功能；路由后，可以做数据处理，发送或者熔断等功能。从这里来讲，echo框架的功能比martini支持的更全面。")]),e._v(" "),r("p",[e._v("router路由器，与martini框架相似，主要实现路由的存储与转发，组路由等功能，web框架必不可少的一环。")]),e._v(" "),r("p",[e._v("Server是服务端的一些重要配置参数，读写超时时间配置；Listener则是请求监听器，web框架跑起来之后，监听器会不停地监听i/o是否有请求写入，这里一般使用i/o多路复用。")]),e._v(" "),r("p",[e._v("Binder是数据处理器，会把请求上下文context中的数据，根据Bind()的结构体格式进行数据解析。Validator是初始化验证，在context.Bind后调用，比如验证传入的结构体是否和Bind()结构体相同。Renderer是用户注册一个渲染模板，请求写入格式以及返回格式是怎么样的，我们都可以通过Renderer来设置。Logger就是自定日志啦。")]),e._v(" "),r("p",[e._v("echo框架整体运行流程，调用e.StartServer启动整个服务端，创建监听器。请求过来之后，调用监听器Accept()方法处理请求，调用ServeHTTP处理请求，获取请求上下文，如果premiddleware不为空，则调用路由分发前的中间件函数，之后调用路由分发，找到对应路由分发后的函数，再调用路由分发后的中间件函数，返回请求值。")]),e._v(" "),r("p",[e._v("框架对比")]),e._v(" "),r("p",[e._v("中间件")]),e._v(" "),r("p",[e._v("marini中间件只支持路由前过滤中间件，echo支持路由前与路由后中间件，同时echo还有很多例如鉴权，访问控制等已写好的中间件。扩展性来讲，echo框架更全面。同时，martini框架使用依赖注入，这会是降低框架执行效率。")]),e._v(" "),r("p",[e._v("路由效率")]),e._v(" "),r("p",[e._v("echo框架的路由基于radix tree基数树，这也是linux内核内存管理中建立索引的重要数据结构，后面有时间会具体讲一下radis tree，同时路由使用了sync pool临时对象池来重复利用内存并且几乎达到了零内存占用。所以echo框架的路由效率这么高。具体radis tree的实现可以看下router.go源代码。而martini的框架，router路由中直接用的[]*route来存储路由，所以效率当然不及echo框架。")]),e._v(" "),r("p",[e._v("总结")]),e._v(" "),r("p",[e._v("echo对比于martini扩展性更强，路由效率更高。其他方面的话，echo框架的功能也更全面，支持TLS安全协议，渲染引擎Renderer配置等。")])])},[],!1,null,null,null);v.default=t.exports}}]);