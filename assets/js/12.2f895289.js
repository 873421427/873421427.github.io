(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{190:function(e,n,r){"use strict";r.r(n);var t=r(0),l=Object(t.a)({},function(){var e=this,n=e.$createElement,r=e._self._c||n;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("p",[e._v("gRPC入门\ngRPC是Google公司基于Protobuf开发的跨语言的开源RPC框架。gRPC基于HTTP/2协议设计，可以基于一个HTTP/2链接提供多个服务，对于移动设备更加友好。本节将讲述gRPC的简单用法。")]),e._v(" "),r("p",[e._v("gRPC技术栈\nGo语言的gRPC技术栈如图4-1所示：")]),e._v(" "),r("p",[e._v("gRPC技术栈")]),e._v(" "),r("p",[e._v("最底层为TCP或Unix Socket协议，在此之上是HTTP/2协议的实现，然后在HTTP/2协议之上又构建了针对Go语言的gRPC核心库。应用程序通过gRPC插件生产的Stub代码和gRPC核心库通信，也可以直接和gRPC核心库通信。")]),e._v(" "),r("p",[e._v("gRPC入门\n如果从Protobuf的角度看，gRPC只不过是一个针对service接口生成代码的生成器。我们在本章的第二节中手工实现了一个简单的Protobuf代码生成器插件，只不过当时生成的代码是适配标准库的RPC框架的。现在我们将学习gRPC的用法。")]),e._v(" "),r("p",[e._v("创建hello.proto文件，定义HelloService接口：")]),e._v(" "),r("p",[e._v('syntax = "proto3";')]),e._v(" "),r("p",[e._v("package main;")]),e._v(" "),r("p",[e._v("message String {\nstring value = 1;\n}")]),e._v(" "),r("p",[e._v("service HelloService {\nrpc Hello (String) returns (String);\n}\n使用protoc-gen-go内置的gRPC插件生成gRPC代码：")]),e._v(" "),r("p",[e._v("$ protoc --go_out=plugins=grpc:. hello.proto\ngRPC插件会为服务端和客户端生成不同的接口：")]),e._v(" "),r("p",[e._v("type HelloServiceServer interface {\nHello(context.Context, *String) (*String, error)\n}")]),e._v(" "),r("p",[e._v("type HelloServiceClient interface {\nHello(context.Context, *String, ...grpc.CallOption) (*String, error)\n}\ngRPC通过context.Context参数，为每个方法调用提供了上下文支持。客户端在调用方法的时候，可以通过可选的grpc.CallOption类型的参数提供额外的上下文信息。")]),e._v(" "),r("p",[e._v("基于服务端的HelloServiceServer接口可以重新实现HelloService服务：")]),e._v(" "),r("p",[e._v("type HelloServiceImpl struct{}")]),e._v(" "),r("p",[e._v('func (p *HelloServiceImpl) Hello(\nctx context.Context, args *String,\n) (*String, error) {\nreply := &String{Value: "hello:" + args.GetValue()}\nreturn reply, nil\n}\ngRPC服务的启动流程和标准库的RPC服务启动流程类似：')]),e._v(" "),r("p",[e._v("func main() {\ngrpcServer := grpc.NewServer()\nRegisterHelloServiceServer(grpcServer, new(HelloServiceImpl))")]),e._v(" "),r("pre",[r("code",[e._v('lis, err := net.Listen("tcp", ":1234")\nif err != nil {\n    log.Fatal(err)\n}\ngrpcServer.Serve(lis)\n')])]),e._v(" "),r("p",[e._v("}\n首先是通过grpc.NewServer()构造一个gRPC服务对象，然后通过gRPC插件生成的RegisterHelloServiceServer函数注册我们实现的HelloServiceImpl服务。然后通过grpcServer.Serve(lis)在一个监听端口上提供gRPC服务。")]),e._v(" "),r("p",[e._v("然后就可以通过客户端链接gRPC服务了：")]),e._v(" "),r("p",[e._v('func main() {\nconn, err := grpc.Dial("localhost:1234", grpc.WithInsecure())\nif err != nil {\nlog.Fatal(err)\n}\ndefer conn.Close()')]),e._v(" "),r("pre",[r("code",[e._v('client := NewHelloServiceClient(conn)\nreply, err := client.Hello(context.Background(), &String{Value: "hello"})\nif err != nil {\n    log.Fatal(err)\n}\nfmt.Println(reply.GetValue())\n')])]),e._v(" "),r("p",[e._v("}\n其中grpc.Dial负责和gRPC服务建立链接，然后NewHelloServiceClient函数基于已经建立的链接构造HelloServiceClient对象。返回的client其实是一个HelloServiceClient接口对象，通过接口定义的方法就可以调用服务端对应的gRPC服务提供的方法。")]),e._v(" "),r("p",[e._v("gRPC和标准库的RPC框架有一个区别，gRPC生成的接口并不支持异步调用。不过我们可以在多个Goroutine之间安全地共享gRPC底层的HTTP/2链接，因此可以通过在另一个Goroutine阻塞调用的方式模拟异步调用。")]),e._v(" "),r("p",[e._v("4.4.3 gRPC流\nRPC是远程函数调用，因此每次调用的函数参数和返回值不能太大，否则将严重影响每次调用的响应时间。因此传统的RPC方法调用对于上传和下载较大数据量场景并不适合。同时传统RPC模式也不适用于对时间不确定的订阅和发布模式。为此，gRPC框架针对服务器端和客户端分别提供了流特性。")]),e._v(" "),r("p",[e._v("服务端或客户端的单向流是双向流的特例，我们在HelloService增加一个支持双向流的Channel方法：")]),e._v(" "),r("p",[e._v("service HelloService {\nrpc Hello (String) returns (String);")]),e._v(" "),r("pre",[r("code",[e._v("rpc Channel (stream String) returns (stream String);\n")])]),e._v(" "),r("p",[e._v("}\n关键字stream指定启用流特性，参数部分是接收客户端参数的流，返回值是返回给客户端的流。")]),e._v(" "),r("p",[e._v("重新生成代码可以看到接口中新增加的Channel方法的定义：")]),e._v(" "),r("p",[e._v("type HelloServiceServer interface {\nHello(context.Context, *String) (*String, error)\nChannel(HelloService_ChannelServer) error\n}\ntype HelloServiceClient interface {\nHello(ctx context.Context, in *String, opts ...grpc.CallOption) (\n*String, error,\n)\nChannel(ctx context.Context, opts ...grpc.CallOption) (\nHelloService_ChannelClient, error,\n)\n}\n在服务端的Channel方法参数是一个新的HelloService_ChannelServer类型的参数，可以用于和客户端双向通信。客户端的Channel方法返回一个HelloService_ChannelClient类型的返回值，可以用于和服务端进行双向通信。")]),e._v(" "),r("p",[e._v("HelloService_ChannelServer和HelloService_ChannelClient均为接口类型：")]),e._v(" "),r("p",[e._v("type HelloService_ChannelServer interface {\nSend(*String) error\nRecv() (*String, error)\ngrpc.ServerStream\n}")]),e._v(" "),r("p",[e._v("type HelloService_ChannelClient interface {\nSend(*String) error\nRecv() (*String, error)\ngrpc.ClientStream\n}\n可以发现服务端和客户端的流辅助接口均定义了Send和Recv方法用于流数据的双向通信。")]),e._v(" "),r("p",[e._v("现在我们可以实现流服务：")]),e._v(" "),r("p",[e._v("func (p *HelloServiceImpl) Channel(stream HelloService_ChannelServer) error {\nfor {\nargs, err := stream.Recv()\nif err != nil {\nif err == io.EOF {\nreturn nil\n}\nreturn err\n}")]),e._v(" "),r("pre",[r("code",[e._v('    reply := &String{Value: "hello:" + args.GetValue()}\n\n    err = stream.Send(reply)\n    if err != nil {\n        return err\n    }\n}\n')])]),e._v(" "),r("p",[e._v("}\n服务端在循环中接收客户端发来的数据，如果遇到io.EOF表示客户端流被关闭，如果函数退出表示服务端流关闭。生成返回的数据通过流发送给客户端，双向流数据的发送和接收都是完全独立的行为。需要注意的是，发送和接收的操作并不需要一一对应，用户可以根据真实场景进行组织代码。")]),e._v(" "),r("p",[e._v("客户端需要先调用Channel方法获取返回的流对象：")]),e._v(" "),r("p",[e._v("stream, err := client.Channel(context.Background())\nif err != nil {\nlog.Fatal(err)\n}\n在客户端我们将发送和接收操作放到两个独立的Goroutine。首先是向服务端发送数据：")]),e._v(" "),r("p",[e._v('go func() {\nfor {\nif err := stream.Send(&String{Value: "hi"}); err != nil {\nlog.Fatal(err)\n}\ntime.Sleep(time.Second)\n}\n}()\n然后在循环中接收服务端返回的数据：')]),e._v(" "),r("p",[e._v("for {\nreply, err := stream.Recv()\nif err != nil {\nif err == io.EOF {\nbreak\n}\nlog.Fatal(err)\n}\nfmt.Println(reply.GetValue())\n}\n这样就完成了完整的流接收和发送支持。")]),e._v(" "),r("p",[e._v("发布和订阅模式\n在前一节中，我们基于Go内置的RPC库实现了一个简化版的Watch方法。基于Watch的思路虽然也可以构造发布和订阅系统，但是因为RPC缺乏流机制导致每次只能返回一个结果。在发布和订阅模式中，由调用者主动发起的发布行为类似一个普通函数调用，而被动的订阅者则类似gRPC客户端单向流中的接收者。现在我们可以尝试基于gRPC的流特性构造一个发布和订阅系统。")]),e._v(" "),r("p",[e._v("发布订阅是一个常见的设计模式，开源社区中已经存在很多该模式的实现。其中docker项目中提供了一个pubsub的极简实现，下面是基于pubsub包实现的本地发布订阅代码：")]),e._v(" "),r("p",[e._v('import (\n"github.com/moby/moby/pkg/pubsub"\n)')]),e._v(" "),r("p",[e._v("func main() {\np := pubsub.NewPublisher(100*time.Millisecond, 10)")]),e._v(" "),r("pre",[r("code",[e._v('golang := p.SubscribeTopic(func(v interface{}) bool {\n    if key, ok := v.(string); ok {\n        if strings.HasPrefix(key, "golang:") {\n            return true\n        }\n    }\n    return false\n})\ndocker := p.SubscribeTopic(func(v interface{}) bool {\n    if key, ok := v.(string); ok {\n        if strings.HasPrefix(key, "docker:") {\n            return true\n        }\n    }\n    return false\n})\n\ngo p.Publish("hi")\ngo p.Publish("golang: https://golang.org")\ngo p.Publish("docker: https://www.docker.com/")\ntime.Sleep(1)\n\ngo func() {\n    fmt.Println("golang topic:", <-golang)\n}()\ngo func() {\n    fmt.Println("docker topic:", <-docker)\n}()\n\n<-make(chan bool)\n')])]),e._v(" "),r("p",[e._v("}\n其中pubsub.NewPublisher构造一个发布对象，p.SubscribeTopic()可以通过函数筛选感兴趣的主题进行订阅。")]),e._v(" "),r("p",[e._v("现在尝试基于gRPC和pubsub包，提供一个跨网络的发布和订阅系统。首先通过Protobuf定义一个发布订阅服务接口：")]),e._v(" "),r("p",[e._v("service PubsubService {\nrpc Publish (String) returns (String);\nrpc Subscribe (String) returns (stream String);\n}\n其中Publish是普通的RPC方法，Subscribe则是一个单向的流服务。然后gRPC插件会为服务端和客户端生成对应的接口：")]),e._v(" "),r("p",[e._v("type PubsubServiceServer interface {\nPublish(context.Context, *String) (*String, error)\nSubscribe(*String, PubsubService_SubscribeServer) error\n}\ntype PubsubServiceClient interface {\nPublish(context.Context, *String, ...grpc.CallOption) (*String, error)\nSubscribe(context.Context, *String, ...grpc.CallOption) (\nPubsubService_SubscribeClient, error,\n)\n}")]),e._v(" "),r("p",[e._v("type PubsubService_SubscribeServer interface {\nSend(*String) error\ngrpc.ServerStream\n}\n因为Subscribe是服务端的单向流，因此生成的HelloService_SubscribeServer接口中只有Send方法。")]),e._v(" "),r("p",[e._v("然后就可以实现发布和订阅服务了：")]),e._v(" "),r("p",[e._v("type PubsubService struct {\npub *pubsub.Publisher\n}")]),e._v(" "),r("p",[e._v("func NewPubsubService() "),r("em",[e._v("PubsubService {\nreturn &PubsubService{\npub: pubsub.NewPublisher(100")]),e._v("time.Millisecond, 10),\n}\n}\n然后是实现发布方法和订阅方法：")]),e._v(" "),r("p",[e._v("func (p *PubsubService) Publish(\nctx context.Context, arg *String,\n) (*String, error) {\np.pub.Publish(arg.GetValue())\nreturn &String{}, nil\n}")]),e._v(" "),r("p",[e._v("func (p *PubsubService) Subscribe(\narg *String, stream PubsubService_SubscribeServer,\n) error {\nch := p.pub.SubscribeTopic(func(v interface{}) bool {\nif key, ok := v.(string); ok {\nif strings.HasPrefix(key,arg.GetValue()) {\nreturn true\n}\n}\nreturn false\n})")]),e._v(" "),r("pre",[r("code",[e._v("for v := range ch {\n    if err := stream.Send(&String{Value: v.(string)}); err != nil {\n        return err\n    }\n}\n\nreturn nil\n")])]),e._v(" "),r("p",[e._v("}\n这样就可以从客户端向服务器发布信息了：")]),e._v(" "),r("p",[e._v('func main() {\nconn, err := grpc.Dial("localhost:1234", grpc.WithInsecure())\nif err != nil {\nlog.Fatal(err)\n}\ndefer conn.Close()')]),e._v(" "),r("pre",[r("code",[e._v('client := NewPubsubServiceClient(conn)\n\n_, err = client.Publish(\n    context.Background(), &String{Value: "golang: hello Go"},\n)\nif err != nil {\n    log.Fatal(err)\n}\n_, err = client.Publish(\n    context.Background(), &String{Value: "docker: hello Docker"},\n)\nif err != nil {\n    log.Fatal(err)\n}\n')])]),e._v(" "),r("p",[e._v("}\n然后就可以在另一个客户端进行订阅信息了：")]),e._v(" "),r("p",[e._v('func main() {\nconn, err := grpc.Dial("localhost:1234", grpc.WithInsecure())\nif err != nil {\nlog.Fatal(err)\n}\ndefer conn.Close()')]),e._v(" "),r("pre",[r("code",[e._v('client := NewPubsubServiceClient(conn)\nstream, err := client.Subscribe(\n    context.Background(), &String{Value: "golang:"},\n)\nif err != nil {\n    log.Fatal(err)\n}\n\nfor {\n    reply, err := stream.Recv()\n    if err != nil {\n        if err == io.EOF {\n            break\n        }\n        log.Fatal(err)\n    }\n\n    fmt.Println(reply.GetValue())\n}\n')])]),e._v(" "),r("p",[e._v("}\n到此我们就基于gRPC简单实现了一个跨网络的发布和订阅服务。")])])},[],!1,null,null,null);n.default=l.exports}}]);