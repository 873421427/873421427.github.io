(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{189:function(e,n,r){"use strict";r.r(n);var t=r(0),v=Object(t.a)({},function(){var e=this,n=e.$createElement,r=e._self._c||n;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"go-原生http服务器实现原理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#go-原生http服务器实现原理","aria-hidden":"true"}},[e._v("#")]),e._v(" Go 原生Http服务器实现原理")]),e._v(" "),r("p",[e._v("在Go中使用及其简单的代码即可开启一个web服务。如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('//开启web服务\nfunc test(){\n    http.HandleFunc("/", sayHello)\n    err := http.ListenAndServe(":9090",nil)\n    if err!=nil {\n        log.Fatal("ListenAndServer:",err)\n    }\n}\n\nfunc sayHello(w http.ResponseWriter, r *http.Request){\n    r.ParseForm()\n    fmt.Println("path",r.URL.Path)\n    fmt.Println("scheme",r.URL.Scheme)\n\n    fmt.Fprintf(w, "Hello Guest!")\n}复制代码\n')])])]),r("p",[e._v("在使用"),r("code",[e._v("ListenAndServe")]),e._v("这个方法时，系统就会给我们指派一个路由器，"),r("code",[e._v("DefaultServeMux")]),e._v("是系统默认使用的路由器，如果"),r("code",[e._v("ListenAndServe")]),e._v("这个方法的第2个参数传入nil，系统就会默认使用"),r("code",[e._v("DefaultServeMux")]),e._v("。当然，这里也可以传入自定义的路由器。")]),e._v(" "),r("p",[e._v("先来看"),r("code",[e._v('http.HandleFunc("/", sayHello)')]),e._v("，从"),r("code",[e._v("HandleFunc")]),e._v("方法点进去，如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("func HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {\n    DefaultServeMux.HandleFunc(pattern, handler)\n}复制代码\n")])])]),r("p",[e._v("在这里调用了"),r("code",[e._v("DefaultServeMux")]),e._v("的"),r("code",[e._v("HandleFunc")]),e._v("方法，这个方法有两个参数，"),r("code",[e._v("pattern")]),e._v("是匹配的路由规则，"),r("code",[e._v("handler")]),e._v("表示这个路由规则对应的处理方法，并且这个处理方法有两个参数。")]),e._v(" "),r("p",[e._v("在我们书写的代码示例中，"),r("code",[e._v("pattern")]),e._v("对应"),r("code",[e._v("/")]),e._v("，"),r("code",[e._v("handler")]),e._v("对应"),r("code",[e._v("sayHello")]),e._v("，当我们在浏览器中输入"),r("code",[e._v("http://localhost:9090")]),e._v("时，就会触发"),r("code",[e._v("sayHello")]),e._v("方法。")]),e._v(" "),r("p",[e._v("我们再顺着"),r("code",[e._v("DefaultServeMux")]),e._v("的"),r("code",[e._v("HandleFunc")]),e._v("方法继续点下去，如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {\n    mux.Handle(pattern, HandlerFunc(handler))\n}\n复制代码\n")])])]),r("p",[e._v("在这个方法中，路由器又调用了"),r("code",[e._v("Handle")]),e._v("方法，注意这个"),r("code",[e._v("Handle")]),e._v("方法的第2个参数，将之前传入的"),r("code",[e._v("handler")]),e._v("这个响应方法强制转换成了"),r("code",[e._v("HandlerFunc")]),e._v("类型。")]),e._v(" "),r("p",[e._v("这个"),r("code",[e._v("HandlerFunc")]),e._v("类型到底是个什么呢？如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("type HandlerFunc func(ResponseWriter, *Request)\n复制代码\n")])])]),r("p",[e._v("看来和我们定义的"),r("code",[e._v("SayHello")]),e._v("方法的类型都差不多。但是！！！\n这个"),r("code",[e._v("HandlerFunc")]),e._v("默认实现了"),r("code",[e._v("ServeHTTP")]),e._v("接口！这样"),r("code",[e._v("HandlerFunc")]),e._v("对象就有了"),r("code",[e._v("ServeHTTP")]),e._v("方法！如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// ServeHTTP calls f(w, r).\nfunc (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {\n    f(w, r)\n}\n复制代码\n")])])]),r("p",[e._v("这个细节是十分重要的，因为这一步关乎到当路由规则匹配时，相应的响应方法是否会被调用的问题！这个方法的调用时机会在下一小节中讲到。")]),e._v(" "),r("p",[e._v("接下来，我们返回去继续看"),r("code",[e._v("mux")]),e._v("的"),r("code",[e._v("Handle")]),e._v("方法，也就是这段代码"),r("code",[e._v("mux.Handle(pattern, HandlerFunc(handler))")]),e._v("。这段代码做了哪些事呢？源码如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('func (mux *ServeMux) Handle(pattern string, handler Handler) {\n    mux.mu.Lock()\n    defer mux.mu.Unlock()\n\n    if pattern == "" {\n        panic("http: invalid pattern " + pattern)\n    }\n    if handler == nil {\n        panic("http: nil handler")\n    }\n    if mux.m[pattern].explicit {\n        panic("http: multiple registrations for " + pattern)\n    }\n\n    if mux.m == nil {\n        mux.m = make(map[string]muxEntry)\n    }\n    mux.m[pattern] = muxEntry{explicit: true, h: handler, pattern: pattern}\n\n    if pattern[0] != \'/\' {\n        mux.hosts = true\n    }\n\n    // Helpful behavior:\n    // If pattern is /tree/, insert an implicit permanent redirect for /tree.\n    // It can be overridden by an explicit registration.\n    n := len(pattern)\n    if n > 0 && pattern[n-1] == \'/\' && !mux.m[pattern[0:n-1]].explicit {\n        // If pattern contains a host name, strip it and use remaining\n        // path for redirect.\n        path := pattern\n        if pattern[0] != \'/\' {\n            // In pattern, at least the last character is a \'/\', so\n            // strings.Index can\'t be -1.\n            path = pattern[strings.Index(pattern, "/"):]\n        }\n        url := &url.URL{Path: path}\n        mux.m[pattern[0:n-1]] = muxEntry{h: RedirectHandler(url.String(), StatusMovedPermanently), pattern: pattern}\n    }\n}\n复制代码\n')])])]),r("p",[e._v("代码挺多，其实主要就做了一件事，向"),r("code",[e._v("DefaultServeMux")]),e._v("的"),r("code",[e._v("map[string]muxEntry")]),e._v("中增加对应的路由规则和"),r("code",[e._v("handler")]),e._v("。")]),e._v(" "),r("p",[r("code",[e._v("map[string]muxEntry")]),e._v("是个什么鬼？")]),e._v(" "),r("p",[r("code",[e._v("map")]),e._v("是一个字典对象，它保存的是"),r("code",[e._v("key-value")]),e._v("。\n"),r("code",[e._v("[string]")]),e._v("表示这个字典的"),r("code",[e._v("key")]),e._v("是"),r("code",[e._v("string")]),e._v("类型的，这个"),r("code",[e._v("key")]),e._v("值会保存我们的路由规则。\n"),r("code",[e._v("muxEntry")]),e._v("是一个实例对象，这个对象内保存了路由规则对应的处理方法。")]),e._v(" "),r("p",[e._v("找到相应代码，如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("//路由器\ntype ServeMux struct {\n    mu    sync.RWMutex\n    m     map[string]muxEntry //路由规则，一个string对应一个mux实例对象，map的key就是注册的路由表达式(string类型的)\n    hosts bool // whether any patterns contain hostnames\n}\n\n//muxEntry\ntype muxEntry struct {\n    explicit bool\n    h        Handler //这个路由表达式对应哪个handler\n    pattern  string\n}\n\n//路由响应方法\ntype Handler interface {\n    ServeHTTP(ResponseWriter, *Request)  //handler的路由实现器\n}\n复制代码\n")])])]),r("p",[r("code",[e._v("ServeMux")]),e._v("就是这个系统默认的路由器。")]),e._v(" "),r("p",[e._v("最后，总结一下这个部分：\n1.调用"),r("code",[e._v('http.HandleFunc("/", sayHello)')]),e._v("\n2.调用"),r("code",[e._v("DefaultServeMux")]),e._v("的"),r("code",[e._v("HandleFunc()")]),e._v("，把我们定义的"),r("code",[e._v("sayHello()")]),e._v("包装成"),r("code",[e._v("HandlerFunc")]),e._v("类型\n3.继续调用"),r("code",[e._v("DefaultServeMux")]),e._v("的"),r("code",[e._v("Handle()")]),e._v("，向"),r("code",[e._v("DefaultServeMux")]),e._v("的"),r("code",[e._v("map[string]muxEntry")]),e._v("中增加路由规则和对应的"),r("code",[e._v("handler")])]),e._v(" "),r("p",[e._v("OK，这部分代码做的事就这么多，第一部分结束。")]),e._v(" "),r("p",[e._v("第二部分主要就是研究这句代码"),r("code",[e._v('err := http.ListenAndServe(":9090",nil)')]),e._v("，也就是"),r("code",[e._v("ListenAndServe")]),e._v("这个方法。从这个方法点进去，如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("func ListenAndServe(addr string, handler Handler) error {\n    server := &Server{Addr: addr, Handler: handler}\n    return server.ListenAndServe()\n}\n复制代码\n")])])]),r("p",[e._v("在这个方法中，初始化了一个"),r("code",[e._v("server")]),e._v("对象，然后调用这个"),r("code",[e._v("server")]),e._v("对象的"),r("code",[e._v("ListenAndServe")]),e._v("方法，在这个方法中，如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('func (srv *Server) ListenAndServe() error {\n    addr := srv.Addr\n    if addr == "" {\n        addr = ":http"\n    }\n    ln, err := net.Listen("tcp", addr)\n    if err != nil {\n        return err\n    }\n    return srv.Serve(tcpKeepAliveListener{ln.(*net.TCPListener)})\n}\n复制代码\n')])])]),r("p",[e._v("在这个方法中，调用了"),r("code",[e._v('net.Listen("tcp", addr)')]),e._v("，也就是底层用TCP协议搭建了一个服务，然后监控我们设置的端口。")]),e._v(" "),r("p",[e._v("代码的最后，调用了"),r("code",[e._v("srv")]),e._v("的"),r("code",[e._v("Serve")]),e._v("方法，如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('func (srv *Server) Serve(l net.Listener) error {\n    defer l.Close()\n    if fn := testHookServerServe; fn != nil {\n        fn(srv, l)\n    }\n    var tempDelay time.Duration // how long to sleep on accept failure\n\n    if err := srv.setupHTTP2_Serve(); err != nil {\n        return err\n    }\n\n    srv.trackListener(l, true)\n    defer srv.trackListener(l, false)\n\n    baseCtx := context.Background() // base is always background, per Issue 16220\n    ctx := context.WithValue(baseCtx, ServerContextKey, srv)\n    ctx = context.WithValue(ctx, LocalAddrContextKey, l.Addr())\n    for {\n        rw, e := l.Accept()\n        if e != nil {\n            select {\n            case <-srv.getDoneChan():\n                return ErrServerClosed\n            default:\n            }\n            if ne, ok := e.(net.Error); ok && ne.Temporary() {\n                if tempDelay == 0 {\n                    tempDelay = 5 * time.Millisecond\n                } else {\n                    tempDelay *= 2\n                }\n                if max := 1 * time.Second; tempDelay > max {\n                    tempDelay = max\n                }\n                srv.logf("http: Accept error: %v; retrying in %v", e, tempDelay)\n                time.Sleep(tempDelay)\n                continue\n            }\n            return e\n        }\n        tempDelay = 0\n        c := srv.newConn(rw)\n        c.setState(c.rwc, StateNew) // before Serve can return\n        go c.serve(ctx)\n    }\n}\n复制代码\n')])])]),r("p",[e._v("最后3段代码比较重要，也是Go语言支持高并发的体现，如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("c := srv.newConn(rw)\nc.setState(c.rwc, StateNew) // before Serve can return\ngo c.serve(ctx)\n复制代码\n")])])]),r("p",[e._v("上面那一大坨代码，总体意思是进入方法后，首先开了一个"),r("code",[e._v("for")]),e._v("循环，在"),r("code",[e._v("for")]),e._v("循环内时刻Accept请求，请求来了之后，会为每个请求创建一个"),r("code",[e._v("Conn")]),e._v("，然后单独开启一个"),r("code",[e._v("goroutine")]),e._v("，把这个请求的数据当做参数扔给这个"),r("code",[e._v("Conn")]),e._v("去服务："),r("code",[e._v("go c.serve()")]),e._v("。用户的每一次请求都是在一个新的"),r("code",[e._v("goroutine")]),e._v("去服务，每个请求间相互不影响。")]),e._v(" "),r("p",[e._v("在"),r("code",[e._v("conn")]),e._v("的"),r("code",[e._v("serve")]),e._v("方法中，有一句代码很重要，如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("serverHandler{c.server}.ServeHTTP(w, w.req)\n复制代码\n")])])]),r("p",[e._v("表示"),r("code",[e._v("serverHandler")])]),e._v(" "),r("p",[e._v("也")]),e._v(" "),r("p",[e._v("实现了"),r("code",[e._v("ServeHTTP")]),e._v("接口，"),r("code",[e._v("ServeHTTP")]),e._v("方法实现如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('func (sh serverHandler) ServeHTTP(rw ResponseWriter, req *Request) {\n    handler := sh.srv.Handler\n    if handler == nil {\n        handler = DefaultServeMux\n    }\n    if req.RequestURI == "*" && req.Method == "OPTIONS" {\n        handler = globalOptionsHandler{}\n    }\n    handler.ServeHTTP(rw, req)\n}\n复制代码\n')])])]),r("p",[e._v("在这里如果"),r("code",[e._v("handler")]),e._v("为空（这个"),r("code",[e._v("handler")]),e._v("就可以理解为是我们自定义的路由器），就会使用系统默认的"),r("code",[e._v("DefaultServeMux")]),e._v("，代码的最后调用了"),r("code",[e._v("DefaultServeMux")]),e._v("的"),r("code",[e._v("ServeHTTP()")])]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request) {\n    if r.RequestURI == "*" {\n        if r.ProtoAtLeast(1, 1) {\n            w.Header().Set("Connection", "close")\n        }\n        w.WriteHeader(StatusBadRequest)\n        return\n    }\n    h, _ := mux.Handler(r)  //这里返回的h是Handler接口对象\n    h.ServeHTTP(w, r)       //调用Handler接口对象的ServeHTTP方法实际上就调用了我们定义的sayHello方法\n}\n复制代码\n')])])]),r("p",[e._v("路由器接收到请求之后，如果是"),r("code",[e._v("*")]),e._v("那么关闭链接，如果不是"),r("code",[e._v("*")]),e._v("就调用"),r("code",[e._v("mux.Handler(r)")]),e._v("返回该路由对应的处理"),r("code",[e._v("Handler")]),e._v("，然后执行该"),r("code",[e._v("handler")]),e._v("的"),r("code",[e._v("ServeHTTP")]),e._v("方法，也就是这句代码"),r("code",[e._v("h.ServeHTTP(w, r)")]),e._v("，"),r("code",[e._v("mux.Handler(r)")]),e._v("做了什么呢？如下：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('func (mux *ServeMux) Handler(r *Request) (h Handler, pattern string) {\n    if r.Method != "CONNECT" {\n        if p := cleanPath(r.URL.Path); p != r.URL.Path {\n            _, pattern = mux.handler(r.Host, p)\n            url := *r.URL\n            url.Path = p\n            return RedirectHandler(url.String(), StatusMovedPermanently), pattern\n        }\n    }\n\n    return mux.handler(r.Host, r.URL.Path)\n}\n\nfunc (mux *ServeMux) handler(host, path string) (h Handler, pattern string) {\n    mux.mu.RLock()\n    defer mux.mu.RUnlock()\n\n    // Host-specific pattern takes precedence over generic ones\n    if mux.hosts {\n        h, pattern = mux.match(host + path)\n    }\n    if h == nil {\n        h, pattern = mux.match(path)\n    }\n    if h == nil {\n        h, pattern = NotFoundHandler(), ""\n    }\n    return\n}\n\nfunc (mux *ServeMux) match(path string) (h Handler, pattern string) {\n    var n = 0\n    for k, v := range mux.m {  //mux.m就是系统默认路由的map\n        if !pathMatch(k, path) {\n            continue\n        }\n        if h == nil || len(k) > n {\n            n = len(k)\n            h = v.h\n            pattern = v.pattern\n        }\n    }\n    return\n}\n复制代码\n')])])]),r("p",[e._v("它会根据用户请求的"),r("code",[e._v("URL")]),e._v("到路由器里面存储的"),r("code",[e._v("map")]),e._v("中匹配，匹配成功就会返回存储的"),r("code",[e._v("handler")]),e._v("，调用这个"),r("code",[e._v("handler")]),e._v("的"),r("code",[e._v("ServeHTTP()")]),e._v("就可以执行到相应的处理方法了，这个处理方法实际上就是我们刚开始定义的"),r("code",[e._v("sayHello()")]),e._v("，只不过这个"),r("code",[e._v("sayHello()")]),e._v("被"),r("code",[e._v("HandlerFunc")]),e._v("又包了一层，因为"),r("code",[e._v("HandlerFunc")]),e._v("实现了"),r("code",[e._v("ServeHTTP")]),e._v("接口，所以在调用"),r("code",[e._v("HandlerFunc")]),e._v("对象的"),r("code",[e._v("ServeHTTP()")]),e._v("时，实际上在"),r("code",[e._v("ServeHTTP ()")]),e._v("的内部调用了我们的"),r("code",[e._v("sayHello()")]),e._v("。")]),e._v(" "),r("p",[e._v("总结一下：\n1.调用"),r("code",[e._v('http.ListenAndServe(":9090",nil)')]),e._v("\n2.实例化"),r("code",[e._v("server")]),e._v("\n3.调用"),r("code",[e._v("server")]),e._v("的"),r("code",[e._v("ListenAndServe()")]),e._v("\n4.调用"),r("code",[e._v("server")]),e._v("的"),r("code",[e._v("Serve")]),e._v("方法，开启"),r("code",[e._v("for")]),e._v("循环，在循环中Accept请求\n5.对每一个请求实例化一个"),r("code",[e._v("Conn")]),e._v("，并且开启一个"),r("code",[e._v("goroutine")]),e._v("为这个请求进行服务"),r("code",[e._v("go c.serve()")]),e._v("\n6.读取每个请求的内容"),r("code",[e._v("c.readRequest()")]),e._v("\n7.调用"),r("code",[e._v("serverHandler")]),e._v("的"),r("code",[e._v("ServeHTTP()")]),e._v("，如果"),r("code",[e._v("handler")]),e._v("为空，就把"),r("code",[e._v("handler")]),e._v("设置为系统默认的路由器"),r("code",[e._v("DefaultServeMux")]),e._v("\n8.调用"),r("code",[e._v("handler")]),e._v("的"),r("code",[e._v("ServeHTTP()")]),e._v(" =>实际上是调用了"),r("code",[e._v("DefaultServeMux")]),e._v("的"),r("code",[e._v("ServeHTTP()")]),e._v("\n9.在"),r("code",[e._v("ServeHTTP()")]),e._v("中会调用路由对应处理"),r("code",[e._v("handler")]),e._v("\n10.在路由对应处理"),r("code",[e._v("handler")]),e._v("中会执行"),r("code",[e._v("sayHello()")])]),e._v(" "),r("p",[e._v("有一个需要注意的点：\n"),r("code",[e._v("DefaultServeMux")]),e._v("和路由对应的处理方法"),r("code",[e._v("handler")]),e._v("都实现了"),r("code",[e._v("ServeHTTP")]),e._v("接口，他们俩都有"),r("code",[e._v("ServeHTTP")]),e._v("方法，但是方法要达到的目的不同，在"),r("code",[e._v("DefaultServeMux")]),e._v("的"),r("code",[e._v("ServeHttp()")]),e._v("里会执行路由对应的处理"),r("code",[e._v("handler")]),e._v("的"),r("code",[e._v("ServeHttp()")]),e._v("。")])])},[],!1,null,null,null);n.default=v.exports}}]);